<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/THREEx.WindowResize.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script>
    var scene = new THREE.Scene();

		/* CONFIG */
		// ref for lumens: http://www.power-sure.com/lumens.htm
			var bulbLuminousPowers = {
				"110000 lm (1000W)": 110000,
				"3500 lm (300W)": 3500,
				"1700 lm (100W)": 1700,
				"800 lm (60W)": 800,
				"400 lm (40W)": 400,
				"180 lm (25W)": 180,
				"20 lm (4W)": 20,
				"Off": 0
			};

		var params = {
				shadows: true,
				exposure: 0.68,
				bulbPower: Object.keys( bulbLuminousPowers )[ 4 ],
			};

		/* CAMERA */
    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth /
      window.innerHeight, 0.1, 1000 );
		camera.position.z = 4;
		camera.position.y = 2;

	//skybox

scene.background = new THREE.CubeTextureLoader().load( [ 
	'./img/bk.png',
	'./img/ft.png',
	'./img/up.png',
	'./img/dn.png',
	'./img/lf.png',
	'./img/rt.png' ] );

		/* RENDERER */
    renderer = new THREE.WebGLRenderer();
		renderer.physicallyCorrectLights = true;
		renderer.gammaInput = true;
		renderer.gammaOutput = true;
		renderer.shadowMap.enabled = true;
		renderer.toneMapping = THREE.ReinhardToneMapping;
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );

		/* MATERIALS */
		var materialBox1 = new THREE.MeshStandardMaterial( { color: 0xcc0000 }
		);

		var materialBox2 = new THREE.MeshStandardMaterial( { color: 0x0000cc }
		);

		/* SHAPES */
    var boxGeometry = new THREE.OctahedronGeometry( 1, 1 );
		var cube = new THREE.Mesh( boxGeometry, materialBox1 );
		var cube2 = new THREE.Mesh( boxGeometry, materialBox2 );
		cube2.position.x = -2;
		cube.position.x = 2;
		cube.position.y = 3;
		cube2.position.y = 3;

		/* FLOOR */
		var floorGeometry = new THREE.PlaneBufferGeometry( 20, 20 );
		floorMat = new THREE.MeshPhongMaterial( {
					roughness: 100,
					color: 0xffffff,
					metalness: 0.0,
					bumpScale: 0.0005
				});
				var floorMesh = new THREE.Mesh( floorGeometry, floorMat );
				floorMesh.receiveShadow = true;
				floorMesh.rotation.x = -Math.PI / 2.0;

		/* TEXTURES */
				var textureLoader = new THREE.TextureLoader();
				textureLoader.load( "texture/grass1.png", function( map ) {
					map.wrapS = THREE.RepeatWrapping;
					map.wrapT = THREE.RepeatWrapping;
					map.anisotropy = 4;
					map.repeat.set( 10, 10 );
					floorMat.map = map;
					floorMat.needsUpdate = true;
				} );
				textureLoader.load( "texture/grass1_bump.png", function( map ) {
					map.wrapS = THREE.RepeatWrapping;
					map.wrapT = THREE.RepeatWrapping;
					map.anisotropy = 4;
					map.repeat.set( 10, 10 );
					floorMat.bumpMap = map;
					floorMat.needsUpdate = true;
				} );
				textureLoader.load( "texture/grass1_rounghness.png", function( map ) {
					map.wrapS = THREE.RepeatWrapping;
					map.wrapT = THREE.RepeatWrapping;
					map.anisotropy = 4;
					map.repeat.set( 10, 10 );
					floorMat.roughnessMap = map;
					floorMat.needsUpdate = true;
				} );


		/* LIGHTS */

		var bulbGeometry = new THREE.SphereBufferGeometry( 0.02, 16, 8 );
				bulbLight = new THREE.PointLight( 0xffee88, 0.5, 100, 2 );
				bulbMat = new THREE.MeshStandardMaterial( {
					emissive: 0xffffee,
					emissiveIntensity: 1,
					color: 0x000000
				});
				bulbLight.add( new THREE.Mesh( bulbGeometry, bulbMat ) );
				bulbLight.position.set( 0, 2, 0 );
				bulbLight.castShadow = true;
				scene.add( bulbLight );

				//SpotLight

			var spotLight = new THREE.SpotLight( 0x4da6ff);
			spotLight.position.set( 110, 10, -100 );

			spotLight.castShadow = true;
			spotLight.intensity = 0;
			spotLight.penumbra =0.20;

			spotLight.shadow.mapSize.width = 2;
			spotLight.shadow.mapSize.height = 2;

			spotLight.shadow.camera.near = 2;
			spotLight.shadow.camera.far = 400;
			spotLight.shadow.camera.fov = 300;

			scene.add( spotLight );

			//particle LIGHT
var particleCount = 11;
var particles = new THREE.SphereGeometry( 0.08, 16, 8 );






for (var p = 0; p < particleCount; p++) {

var pX =Math.random() * 20 - 10,
pY = Math.random() * 5,
pZ = Math.random() * 20 - 10;

var color = getRandomColor();
var pMaterial = new THREE.MeshStandardMaterial( {
					emissive: color,
					emissiveIntensity: 50,
					color: color
				});

var particleSystem = new THREE.PointLight( color , 5, 100 );

particleSystem.add( new THREE.Mesh( particles, pMaterial ) );
particleSystem.position.set( pX, pY, pZ );
particleSystem.castShadow = true;
scene.add(particleSystem);


}









scene.add( cube );
scene.add( cube2 );
scene.add( floorMesh );


renderer.render( scene, camera );
control = new THREE.OrbitControls(camera,renderer.domElement);
THREEx.WindowResize(renderer, camera);

function animate() {
	requestAnimationFrame( animate );
	render();
  //cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;
	//cube2.rotation.x += 0.01;
	cube2.rotation.y -= 0.01;
}

animate();

function render() {
	renderer.toneMappingExposure = Math.pow( params.exposure, 5.0 ); // to allow for very bright scenes.
				renderer.shadowMap.enabled = params.shadows;
				bulbLight.castShadow = params.shadows;

				bulbLight.power = bulbLuminousPowers[ params.bulbPower ];
				bulbMat.emissiveIntensity = bulbLight.intensity / Math.pow( 0.02, 2.0 ); // convert from intensity to irradiance at bulb surface
				var time = Date.now() * 0.0005;
				bulbLight.position.y = Math.cos( time ) * 0.75 + 1.25;
				renderer.render( scene, camera );
}
function getRandomColor() {
  var letters = '0123456789ABCDEF';
  var color = '#';
  for (var i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }
  return color;
}
		</script>
	</body>
</html>
